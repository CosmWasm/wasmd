// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: wasmvm.proto

package proto

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	WasmVMService_LoadModule_FullMethodName  = "/cosmwasm.WasmVMService/LoadModule"
	WasmVMService_Instantiate_FullMethodName = "/cosmwasm.WasmVMService/Instantiate"
	WasmVMService_Execute_FullMethodName     = "/cosmwasm.WasmVMService/Execute"
	WasmVMService_Query_FullMethodName       = "/cosmwasm.WasmVMService/Query"
	WasmVMService_Migrate_FullMethodName     = "/cosmwasm.WasmVMService/Migrate"
	WasmVMService_Sudo_FullMethodName        = "/cosmwasm.WasmVMService/Sudo"
	WasmVMService_Reply_FullMethodName       = "/cosmwasm.WasmVMService/Reply"
	WasmVMService_AnalyzeCode_FullMethodName = "/cosmwasm.WasmVMService/AnalyzeCode"
)

// WasmVMServiceClient is the client API for WasmVMService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WasmVMServiceClient interface {
	LoadModule(ctx context.Context, in *LoadModuleRequest, opts ...grpc.CallOption) (*LoadModuleResponse, error)
	Instantiate(ctx context.Context, in *InstantiateRequest, opts ...grpc.CallOption) (*InstantiateResponse, error)
	Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error)
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error)
	Migrate(ctx context.Context, in *MigrateRequest, opts ...grpc.CallOption) (*MigrateResponse, error)
	Sudo(ctx context.Context, in *SudoRequest, opts ...grpc.CallOption) (*SudoResponse, error)
	Reply(ctx context.Context, in *ReplyRequest, opts ...grpc.CallOption) (*ReplyResponse, error)
	AnalyzeCode(ctx context.Context, in *AnalyzeCodeRequest, opts ...grpc.CallOption) (*AnalyzeCodeResponse, error)
}

type wasmVMServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWasmVMServiceClient(cc grpc.ClientConnInterface) WasmVMServiceClient {
	return &wasmVMServiceClient{cc}
}

func (c *wasmVMServiceClient) LoadModule(ctx context.Context, in *LoadModuleRequest, opts ...grpc.CallOption) (*LoadModuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadModuleResponse)
	err := c.cc.Invoke(ctx, WasmVMService_LoadModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wasmVMServiceClient) Instantiate(ctx context.Context, in *InstantiateRequest, opts ...grpc.CallOption) (*InstantiateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InstantiateResponse)
	err := c.cc.Invoke(ctx, WasmVMService_Instantiate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wasmVMServiceClient) Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteResponse)
	err := c.cc.Invoke(ctx, WasmVMService_Execute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wasmVMServiceClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, WasmVMService_Query_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wasmVMServiceClient) Migrate(ctx context.Context, in *MigrateRequest, opts ...grpc.CallOption) (*MigrateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MigrateResponse)
	err := c.cc.Invoke(ctx, WasmVMService_Migrate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wasmVMServiceClient) Sudo(ctx context.Context, in *SudoRequest, opts ...grpc.CallOption) (*SudoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SudoResponse)
	err := c.cc.Invoke(ctx, WasmVMService_Sudo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wasmVMServiceClient) Reply(ctx context.Context, in *ReplyRequest, opts ...grpc.CallOption) (*ReplyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReplyResponse)
	err := c.cc.Invoke(ctx, WasmVMService_Reply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wasmVMServiceClient) AnalyzeCode(ctx context.Context, in *AnalyzeCodeRequest, opts ...grpc.CallOption) (*AnalyzeCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnalyzeCodeResponse)
	err := c.cc.Invoke(ctx, WasmVMService_AnalyzeCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WasmVMServiceServer is the server API for WasmVMService service.
// All implementations must embed UnimplementedWasmVMServiceServer
// for forward compatibility.
type WasmVMServiceServer interface {
	LoadModule(context.Context, *LoadModuleRequest) (*LoadModuleResponse, error)
	Instantiate(context.Context, *InstantiateRequest) (*InstantiateResponse, error)
	Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error)
	Query(context.Context, *QueryRequest) (*QueryResponse, error)
	Migrate(context.Context, *MigrateRequest) (*MigrateResponse, error)
	Sudo(context.Context, *SudoRequest) (*SudoResponse, error)
	Reply(context.Context, *ReplyRequest) (*ReplyResponse, error)
	AnalyzeCode(context.Context, *AnalyzeCodeRequest) (*AnalyzeCodeResponse, error)
	mustEmbedUnimplementedWasmVMServiceServer()
}

// UnimplementedWasmVMServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWasmVMServiceServer struct{}

func (UnimplementedWasmVMServiceServer) LoadModule(context.Context, *LoadModuleRequest) (*LoadModuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadModule not implemented")
}

func (UnimplementedWasmVMServiceServer) Instantiate(context.Context, *InstantiateRequest) (*InstantiateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Instantiate not implemented")
}

func (UnimplementedWasmVMServiceServer) Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}

func (UnimplementedWasmVMServiceServer) Query(context.Context, *QueryRequest) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}

func (UnimplementedWasmVMServiceServer) Migrate(context.Context, *MigrateRequest) (*MigrateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Migrate not implemented")
}

func (UnimplementedWasmVMServiceServer) Sudo(context.Context, *SudoRequest) (*SudoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sudo not implemented")
}

func (UnimplementedWasmVMServiceServer) Reply(context.Context, *ReplyRequest) (*ReplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reply not implemented")
}

func (UnimplementedWasmVMServiceServer) AnalyzeCode(context.Context, *AnalyzeCodeRequest) (*AnalyzeCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnalyzeCode not implemented")
}
func (UnimplementedWasmVMServiceServer) mustEmbedUnimplementedWasmVMServiceServer() {}
func (UnimplementedWasmVMServiceServer) testEmbeddedByValue()                       {}

// UnsafeWasmVMServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WasmVMServiceServer will
// result in compilation errors.
type UnsafeWasmVMServiceServer interface {
	mustEmbedUnimplementedWasmVMServiceServer()
}

func RegisterWasmVMServiceServer(s grpc.ServiceRegistrar, srv WasmVMServiceServer) {
	// If the following call pancis, it indicates UnimplementedWasmVMServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WasmVMService_ServiceDesc, srv)
}

func _WasmVMService_LoadModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadModuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WasmVMServiceServer).LoadModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WasmVMService_LoadModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WasmVMServiceServer).LoadModule(ctx, req.(*LoadModuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WasmVMService_Instantiate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstantiateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WasmVMServiceServer).Instantiate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WasmVMService_Instantiate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WasmVMServiceServer).Instantiate(ctx, req.(*InstantiateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WasmVMService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WasmVMServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WasmVMService_Execute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WasmVMServiceServer).Execute(ctx, req.(*ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WasmVMService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WasmVMServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WasmVMService_Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WasmVMServiceServer).Query(ctx, req.(*QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WasmVMService_Migrate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WasmVMServiceServer).Migrate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WasmVMService_Migrate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WasmVMServiceServer).Migrate(ctx, req.(*MigrateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WasmVMService_Sudo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SudoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WasmVMServiceServer).Sudo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WasmVMService_Sudo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WasmVMServiceServer).Sudo(ctx, req.(*SudoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WasmVMService_Reply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WasmVMServiceServer).Reply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WasmVMService_Reply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WasmVMServiceServer).Reply(ctx, req.(*ReplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WasmVMService_AnalyzeCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyzeCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WasmVMServiceServer).AnalyzeCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WasmVMService_AnalyzeCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WasmVMServiceServer).AnalyzeCode(ctx, req.(*AnalyzeCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WasmVMService_ServiceDesc is the grpc.ServiceDesc for WasmVMService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WasmVMService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cosmwasm.WasmVMService",
	HandlerType: (*WasmVMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoadModule",
			Handler:    _WasmVMService_LoadModule_Handler,
		},
		{
			MethodName: "Instantiate",
			Handler:    _WasmVMService_Instantiate_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _WasmVMService_Execute_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _WasmVMService_Query_Handler,
		},
		{
			MethodName: "Migrate",
			Handler:    _WasmVMService_Migrate_Handler,
		},
		{
			MethodName: "Sudo",
			Handler:    _WasmVMService_Sudo_Handler,
		},
		{
			MethodName: "Reply",
			Handler:    _WasmVMService_Reply_Handler,
		},
		{
			MethodName: "AnalyzeCode",
			Handler:    _WasmVMService_AnalyzeCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "wasmvm.proto",
}

const (
	HostService_CallHostFunction_FullMethodName = "/cosmwasm.HostService/CallHostFunction"
)

// HostServiceClient is the client API for HostService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HostServiceClient interface {
	CallHostFunction(ctx context.Context, in *CallHostFunctionRequest, opts ...grpc.CallOption) (*CallHostFunctionResponse, error)
}

type hostServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHostServiceClient(cc grpc.ClientConnInterface) HostServiceClient {
	return &hostServiceClient{cc}
}

func (c *hostServiceClient) CallHostFunction(ctx context.Context, in *CallHostFunctionRequest, opts ...grpc.CallOption) (*CallHostFunctionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CallHostFunctionResponse)
	err := c.cc.Invoke(ctx, HostService_CallHostFunction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HostServiceServer is the server API for HostService service.
// All implementations must embed UnimplementedHostServiceServer
// for forward compatibility.
type HostServiceServer interface {
	CallHostFunction(context.Context, *CallHostFunctionRequest) (*CallHostFunctionResponse, error)
	mustEmbedUnimplementedHostServiceServer()
}

// UnimplementedHostServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHostServiceServer struct{}

func (UnimplementedHostServiceServer) CallHostFunction(context.Context, *CallHostFunctionRequest) (*CallHostFunctionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallHostFunction not implemented")
}
func (UnimplementedHostServiceServer) mustEmbedUnimplementedHostServiceServer() {}
func (UnimplementedHostServiceServer) testEmbeddedByValue()                     {}

// UnsafeHostServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HostServiceServer will
// result in compilation errors.
type UnsafeHostServiceServer interface {
	mustEmbedUnimplementedHostServiceServer()
}

func RegisterHostServiceServer(s grpc.ServiceRegistrar, srv HostServiceServer) {
	// If the following call pancis, it indicates UnimplementedHostServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HostService_ServiceDesc, srv)
}

func _HostService_CallHostFunction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallHostFunctionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).CallHostFunction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostService_CallHostFunction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).CallHostFunction(ctx, req.(*CallHostFunctionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HostService_ServiceDesc is the grpc.ServiceDesc for HostService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HostService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cosmwasm.HostService",
	HandlerType: (*HostServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CallHostFunction",
			Handler:    _HostService_CallHostFunction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "wasmvm.proto",
}
