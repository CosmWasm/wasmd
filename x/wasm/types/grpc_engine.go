// Code generated by the gRPC engine adapter -- DO NOT EDIT.
// Provides a WasmEngine implementation that forwards calls to a remote WasmVMService.
package types

import (
	"context"
	"encoding/json"
	"errors"
	"strings"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"

	wasmvm "github.com/CosmWasm/wasmvm/v2"
	wasmgrpc "github.com/CosmWasm/wasmd/proto"
	wasmvmtypes "github.com/CosmWasm/wasmvm/v2/types"
)

// grpcEngine is a WasmEngine implementation using gRPC to talk to a remote WasmVMService.
type grpcEngine struct {
	client wasmgrpc.WasmVMServiceClient
	conn   *grpc.ClientConn
}

// NewGRPCEngine connects to the WasmVMService at addr (default localhost:50051) and returns a WasmEngine.
func NewGRPCEngine(addr string) (WasmEngine, error) {
	if addr == "" {
		addr = "localhost:50051"
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	conn, err := grpc.DialContext(ctx, addr, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())
	if err != nil {
		return nil, err
	}
	client := wasmgrpc.NewWasmVMServiceClient(conn)
	return &grpcEngine{client: client, conn: conn}, nil
}

func (g *grpcEngine) StoreCode(code wasmvm.WasmCode, gasLimit uint64) (wasmvm.Checksum, uint64, error) {
	req := &wasmgrpc.LoadModuleRequest{ModuleBytes: code}
	resp, err := g.client.LoadModule(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, 0, errors.New(resp.Error)
	}
	return wasmvmtypes.Checksum(resp.Checksum), 0, nil
}

func (g *grpcEngine) StoreCodeUnchecked(code wasmvm.WasmCode) (wasmvm.Checksum, error) {
	req := &wasmgrpc.LoadModuleRequest{ModuleBytes: code}
	resp, err := g.client.LoadModule(context.Background(), req)
	if err != nil {
		return nil, err
	}
	if resp.Error != "" {
		return nil, errors.New(resp.Error)
	}
	return wasmvmtypes.Checksum(resp.Checksum), nil
}

func (g *grpcEngine) SimulateStoreCode(code wasmvm.WasmCode, gasLimit uint64) (wasmvm.Checksum, uint64, error) {
	return g.StoreCode(code, gasLimit)
}

func (g *grpcEngine) AnalyzeCode(checksum wasmvmtypes.Checksum) (*wasmvmtypes.AnalysisReport, error) {
	req := &wasmgrpc.AnalyzeCodeRequest{Checksum: string(checksum)}
	resp, err := g.client.AnalyzeCode(context.Background(), req)
	if err != nil {
		return nil, err
	}
	if resp.Error != "" {
		return nil, errors.New(resp.Error)
	}
	return &wasmvmtypes.AnalysisReport{
		RequiredCapabilities: strings.Join(resp.RequiredCapabilities, ","),
		HasIBCEntryPoints:    resp.HasIbcEntryPoints,
	}, nil
}

func (g *grpcEngine) Instantiate(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	info wasmvmtypes.MessageInfo,
	initMsg []byte,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.ContractResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: info.Sender, ChainId: env.Block.ChainID}
	req := &wasmgrpc.InstantiateRequest{Checksum: string(checksum), Context: ctx, InitMsg: initMsg, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.Instantiate(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.ContractResult{Ok: &wasmvmtypes.Response{Data: resp.Data}}, resp.GasUsed, nil
}

func (g *grpcEngine) Execute(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	info wasmvmtypes.MessageInfo,
	executeMsg []byte,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.ContractResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: info.Sender, ChainId: env.Block.ChainID}
	req := &wasmgrpc.ExecuteRequest{ContractId: string(checksum), Context: ctx, Msg: executeMsg, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.Execute(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.ContractResult{Ok: &wasmvmtypes.Response{Data: resp.Data}}, resp.GasUsed, nil
}

func (g *grpcEngine) Query(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	queryMsg []byte,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.QueryResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	req := &wasmgrpc.QueryRequest{ContractId: string(checksum), Context: ctx, QueryMsg: queryMsg, RequestId: ""}
	resp, err := g.client.Query(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, 0, errors.New(resp.Error)
	}
	return &wasmvmtypes.QueryResult{Ok: resp.Result}, 0, nil
}

func (g *grpcEngine) Migrate(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	migrateMsg []byte,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.ContractResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	req := &wasmgrpc.MigrateRequest{ContractId: string(checksum), Checksum: string(checksum), Context: ctx, MigrateMsg: migrateMsg, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.Migrate(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.ContractResult{Ok: &wasmvmtypes.Response{Data: resp.Data}}, resp.GasUsed, nil
}

func (g *grpcEngine) MigrateWithInfo(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	migrateMsg []byte,
	migrateInfo wasmvmtypes.MigrateInfo,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.ContractResult, uint64, error) {
	// For now, we'll use the regular Migrate method as the proto doesn't have a separate MigrateWithInfo
	return g.Migrate(checksum, env, migrateMsg, store, goapi, querier, gasMeter, gasLimit, deserCost)
}

func (g *grpcEngine) Sudo(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	sudoMsg []byte,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.ContractResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	req := &wasmgrpc.SudoRequest{ContractId: string(checksum), Context: ctx, Msg: sudoMsg, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.Sudo(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.ContractResult{Ok: &wasmvmtypes.Response{Data: resp.Data}}, resp.GasUsed, nil
}

func (g *grpcEngine) Reply(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	reply wasmvmtypes.Reply,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.ContractResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	replyMsg, err := json.Marshal(reply)
	if err != nil {
		return nil, 0, err
	}
	req := &wasmgrpc.ReplyRequest{ContractId: string(checksum), Context: ctx, ReplyMsg: replyMsg, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.Reply(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.ContractResult{Ok: &wasmvmtypes.Response{Data: resp.Data}}, resp.GasUsed, nil
}

func (g *grpcEngine) GetCode(checksum wasmvmtypes.Checksum) (wasmvm.WasmCode, error) {
	req := &wasmgrpc.GetCodeRequest{Checksum: string(checksum)}
	resp, err := g.client.GetCode(context.Background(), req)
	if err != nil {
		return nil, err
	}
	if resp.Error != "" {
		return nil, errors.New(resp.Error)
	}
	return resp.ModuleBytes, nil
}

func (g *grpcEngine) Cleanup() {
	if g.conn != nil {
		g.conn.Close()
	}
}

func (g *grpcEngine) Pin(checksum wasmvmtypes.Checksum) error {
	req := &wasmgrpc.PinModuleRequest{Checksum: string(checksum)}
	resp, err := g.client.PinModule(context.Background(), req)
	if err != nil {
		return err
	}
	if resp.Error != "" {
		return errors.New(resp.Error)
	}
	return nil
}

func (g *grpcEngine) Unpin(checksum wasmvmtypes.Checksum) error {
	req := &wasmgrpc.UnpinModuleRequest{Checksum: string(checksum)}
	resp, err := g.client.UnpinModule(context.Background(), req)
	if err != nil {
		return err
	}
	if resp.Error != "" {
		return errors.New(resp.Error)
	}
	return nil
}

func (g *grpcEngine) GetMetrics() (*wasmvmtypes.Metrics, error) {
	req := &wasmgrpc.GetMetricsRequest{}
	resp, err := g.client.GetMetrics(context.Background(), req)
	if err != nil {
		return nil, err
	}
	if resp.Error != "" {
		return nil, errors.New(resp.Error)
	}
	if resp.Metrics == nil {
		return nil, errors.New("no metrics returned")
	}
	return &wasmvmtypes.Metrics{
		HitsPinnedMemoryCache:     resp.Metrics.HitsPinnedMemoryCache,
		HitsMemoryCache:          resp.Metrics.HitsMemoryCache,
		HitsFsCache:              resp.Metrics.HitsFsCache,
		Misses:                   resp.Metrics.Misses,
		ElementsPinnedMemoryCache: resp.Metrics.ElementsPinnedMemoryCache,
		ElementsMemoryCache:      resp.Metrics.ElementsMemoryCache,
		SizePinnedMemoryCache:    resp.Metrics.SizePinnedMemoryCache,
		SizeMemoryCache:          resp.Metrics.SizeMemoryCache,
	}, nil
}

func (g *grpcEngine) GetPinnedMetrics() (*wasmvmtypes.PinnedMetrics, error) {
	req := &wasmgrpc.GetPinnedMetricsRequest{}
	resp, err := g.client.GetPinnedMetrics(context.Background(), req)
	if err != nil {
		return nil, err
	}
	if resp.Error != "" {
		return nil, errors.New(resp.Error)
	}
	if resp.PinnedMetrics == nil {
		return nil, errors.New("no pinned metrics returned")
	}
	
	var perModule []wasmvmtypes.PerModuleEntry
	for checksum, metrics := range resp.PinnedMetrics.PerModule {
		perModule = append(perModule, wasmvmtypes.PerModuleEntry{
			Checksum: wasmvmtypes.Checksum(checksum),
			Metrics: wasmvmtypes.PerModuleMetrics{
				Hits: metrics.Hits,
				Size: metrics.Size,
			},
		})
	}
	
	return &wasmvmtypes.PinnedMetrics{
		PerModule: perModule,
	}, nil
}

// IBC methods - now implemented using the new proto definitions
func (g *grpcEngine) IBCChannelOpen(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	channel wasmvmtypes.IBCChannelOpenMsg,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.IBCChannelOpenResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	// Serialize the channel message - this would need proper serialization in a real implementation
	msgBytes := []byte{} // TODO: serialize channel properly
	req := &wasmgrpc.IbcMsgRequest{Checksum: string(checksum), Context: ctx, Msg: msgBytes, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.IbcChannelOpen(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	// TODO: properly deserialize the response data into IBCChannelOpenResult
	return &wasmvmtypes.IBCChannelOpenResult{}, resp.GasUsed, nil
}

func (g *grpcEngine) IBCChannelConnect(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	channel wasmvmtypes.IBCChannelConnectMsg,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.IBCBasicResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	msgBytes := []byte{} // TODO: serialize channel properly
	req := &wasmgrpc.IbcMsgRequest{Checksum: string(checksum), Context: ctx, Msg: msgBytes, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.IbcChannelConnect(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.IBCBasicResult{}, resp.GasUsed, nil
}

func (g *grpcEngine) IBCChannelClose(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	channel wasmvmtypes.IBCChannelCloseMsg,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.IBCBasicResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	msgBytes := []byte{} // TODO: serialize channel properly
	req := &wasmgrpc.IbcMsgRequest{Checksum: string(checksum), Context: ctx, Msg: msgBytes, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.IbcChannelClose(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.IBCBasicResult{}, resp.GasUsed, nil
}

func (g *grpcEngine) IBCPacketReceive(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	packet wasmvmtypes.IBCPacketReceiveMsg,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.IBCReceiveResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	msgBytes := []byte{} // TODO: serialize packet properly
	req := &wasmgrpc.IbcMsgRequest{Checksum: string(checksum), Context: ctx, Msg: msgBytes, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.IbcPacketReceive(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.IBCReceiveResult{}, resp.GasUsed, nil
}

func (g *grpcEngine) IBCPacketAck(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	ack wasmvmtypes.IBCPacketAckMsg,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.IBCBasicResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	msgBytes := []byte{} // TODO: serialize ack properly
	req := &wasmgrpc.IbcMsgRequest{Checksum: string(checksum), Context: ctx, Msg: msgBytes, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.IbcPacketAck(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.IBCBasicResult{}, resp.GasUsed, nil
}

func (g *grpcEngine) IBCPacketTimeout(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	packet wasmvmtypes.IBCPacketTimeoutMsg,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.IBCBasicResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	msgBytes := []byte{} // TODO: serialize packet properly
	req := &wasmgrpc.IbcMsgRequest{Checksum: string(checksum), Context: ctx, Msg: msgBytes, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.IbcPacketTimeout(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.IBCBasicResult{}, resp.GasUsed, nil
}

func (g *grpcEngine) IBCSourceCallback(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	msg wasmvmtypes.IBCSourceCallbackMsg,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.IBCBasicResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	msgBytes := []byte{} // TODO: serialize msg properly
	req := &wasmgrpc.IbcMsgRequest{Checksum: string(checksum), Context: ctx, Msg: msgBytes, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.IbcSourceCallback(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.IBCBasicResult{}, resp.GasUsed, nil
}

func (g *grpcEngine) IBCDestinationCallback(
	checksum wasmvmtypes.Checksum,
	env wasmvmtypes.Env,
	msg wasmvmtypes.IBCDestinationCallbackMsg,
	store wasmvmtypes.KVStore,
	goapi wasmvmtypes.GoAPI,
	querier wasmvmtypes.Querier,
	gasMeter wasmvmtypes.GasMeter,
	gasLimit uint64,
	deserCost wasmvmtypes.UFraction,
) (*wasmvmtypes.IBCBasicResult, uint64, error) {
	ctx := &wasmgrpc.Context{BlockHeight: env.Block.Height, Sender: "", ChainId: env.Block.ChainID}
	msgBytes := []byte{} // TODO: serialize msg properly
	req := &wasmgrpc.IbcMsgRequest{Checksum: string(checksum), Context: ctx, Msg: msgBytes, GasLimit: gasLimit, RequestId: ""}
	resp, err := g.client.IbcDestinationCallback(context.Background(), req)
	if err != nil {
		return nil, 0, err
	}
	if resp.Error != "" {
		return nil, resp.GasUsed, errors.New(resp.Error)
	}
	return &wasmvmtypes.IBCBasicResult{}, resp.GasUsed, nil
}